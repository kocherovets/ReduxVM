# Описание
ReduxVM - это библиотека для построения iOS приложения по определенной архитектуре. Структурная схема этой архитектуры выглядит следующим образом:

<img width="600" alt="ReduxVM" src="https://user-images.githubusercontent.com/4235844/74607773-a5a85d80-50ec-11ea-8f91-7bf480f99698.png">


Стрелками изображено движение данных между модулями системы. Как видно ReduxVM реализует однонаправленную архитектуру. Единственное место, где это правило нарушается - это сайдэффекты. Поскольку данные могут передаваться только в одном направлении, гораздо проще визуально следовать за кодом и выявлять любые проблемы в приложении.

Вся схема разделена на две части - Background и Foreground. ReduxVM автоматически реализует это разделение. В соответствии с названием эти части выполняются либо на основном, либо в фоновом потоках. Так как в основном потоке выполняется только модуль View, то ReduxVM из коробки исключает блокирование UI работой других модулей программы. Нужно отметить, что весь блок Background работает в одном и том же потоке синхронно. Но каждый Action добавляет новую задачу в этом поток, так что все Actions выполняются один за другим не перекрываясь.

Перечислим все модули и дадим их краткое описание.
- **State** хранит текущее состояние приложения и позволяет на себя подписаться чтобы отслеживать изменения. В ReduxVM к модулю State подключаются модули Presenter и Service, но можно и непосредственно подписаться на State, если это понадобится. State представляет собой swift структуру, которая обычно состоит из нескольких подструктур описывающих разные разделы бизнес логики. 
- **Action** инициирует изменение состояния в приложении. Представляет собой swift структуру. Его назначение просто через свой тип и возможные поля хранить информацию о текущем действии. Action из View переводится в фоновый поток и далее обрабатывается уже в нем. Важно понимать, что изменить State можно только с помощью Action. Только у Action есть доступ к State на запись.
- **Reducer** представляет собой чистую синхронную функцию меняющую State. В ReduxVM Reducer программно является методом структуры Action принимающую на вход текущий State и на выходе выдающую новый State, который перезаписывает текущий. Строго говоря State передается как inout параметр. Тут важно отметить, что это именно чистая функция и кроме как поменять одну структуру на другую - старый стейт на новый, ей запрещено что-то делать. Reducer всегда срабатывает один раз после регистрации в системе нового Action.
- **Presenter** представляет собой связующее звено между State и UI. При создании View также создается относящийся к нему Presenter. Presenter при создании подписывается на State и далее получает от него уведомления, когда State изменяется. Существуют несколько механизмов по оптимизации лишних вызовов Presenter из State. Задачей Presenter является трансляция данных из State в Props для того View, к которому он привязан.
- **Props** представляет собой структуру, содержащую простую информацию для отображения в UI посредством модуля View. К такой информации относятся строки, числа, даты и другие примитивные типы данных. Поля описывают именно структуру того View, к которому относится Props, причем без ссылок на предметную область и бизнес логику. Также в Props могут содержаться триггеры с Action. Props не знает, что это за Action и зачем они нужны, он просто их хранит. 
View является наследником UIViewController и должен просто отображать передаваемую ему в Props информацию. Также он знает, например, что при нажатии на кнопку, он должен запустить определенный Action из Props, но как и Props не имеет представления что именно он запускает. Важно отметить, что View не должен знать вообще ничего про бизнес логику и если и хранить какую-то информацию о состоянии приложения, то это должна быть информация касающаяся исключительно UI. Например, состояние анимации в данном UIViewController.
- **Service** представляет собой подписчиков к Store не связанных напрямую с UI, то есть код Service выполняется в фоновом потоке. Service является управляющей сущностью для некоторого набора SideEffects обычно логически связанных с точки зрения программы. Например, это может быть сервис для работы с сетью. При изменении State каждый Service опрашивает свои SideEffects узнавая должны ли они запуститься и если должны, то запускает.
- **SideEffect** состоит из двух частей. Первая - это проверка срабатывания на основании текущего состояния State. Вторая - некоторое действие как реакция на изменение State. SideEffect не имеет доступа к State на запись, поэтому после какой-то работы, например, получения данных из сети, SideEffect регистрирует в системе Action, который уже изменит State.

ReduxVM для всех подписчиков на State предоставляется не только текущую версию State, а специальный объект Box. В котором содержится текущее состояние State, предыдущее состояние State, Action приведший к этому изменению и набор вспомогательных методов для упрощения анализа текущей ситуации.

# Плюсы и минусы

Плюсы:

- Большое количество стандартизированных модулей позволяют после обучения легко локализовать место требующее внимания.
Однонаправленный поток данных: приложения, реализующие многонаправленный поток данных, могут быть очень трудными для чтения и отладки. Одно изменение может привести к цепочке событий, которые отправляют данные по всему приложению. Однонаправленный поток более предсказуем и значительно снижает когнитивную нагрузку, необходимую для чтения кода.
- В настоящее время нет хорошего способа обработки Cross CuttingConcern в Swift. В ReduxVM, вы получите его бесплатно. Вы можете решать различные задачи, используя сервисы. Это позволяет легко справиться с такими задачами как ведением журнала или статистикой.
- Тестирование: ReduxVM создавалась с целью, помимо всего прочего, быть очень простой для написания тестов. Reducers содержат код, необходимый для тестирования и они являются чистыми функциями. Чистые функции всегда дают один и тот же результат для того же входа, не полагаются на состояние приложения и не имеют побочных эффектов. 
- В ReduxVM модуль Presenter при стандартной, чего обычно достаточно, реализации также представляет собой одну или две чистых функции, что делает тестирование очень простым. Модуль Props тестирования не требует. 
- Модуль View зависит только от своих Props, потому просто создавая тестовые заполнения структуры Props, можно рендерить View с любыми нужными данными и проверять его работу, например, сравнивая получившиеся скриншоты с образцом.
- Часть SideEffect отвечающая за проверку срабатываемости также является чистой функцией.
Тестировании оставшейся части SideEffect можно также радикально упростить, если следовать подходу изложенному в докладе. ReduxVM поддерживаем его естественным образом.
- Отладка: при условии, что состояние определено в одной структуре и однонаправленном потоке, отладка намного проще. 
- Из-за того, что практически вся активность в системе запускается через Action, а Action проходит по одному и тому же пути, можно выводить в лог практически всю информацию по работе приложения, что и делается, что также очень сильно помогает в отладке.
- Также можно упростить разработку, сформировав тестовое заполнение Store нужными данными и показав сразу при старте нужный экран приложения. Так как работа экрана зависит только от связки State -> Presenter -> Props -> View, то можно сразу увидеть как он будет выглядеть минуя возможно долгий путь к этому экрану обычным способом.
- Хорошая справляется с ростом приложения. Так как состояние всего приложения хранится в древовидной структуре, то просто добавляя туда нужные подструктуры можно расширять модель данных поддерживаемых приложением.
- Это также ведет к одному из возможных решения проблемы поддержки нескольких приложений с базовой функциональностью. Можно остаться в рамках одного проекта и завести несколько таргетов, который в том числе будут просто предоставлять разный исходный код по сбору State из подструктур. В каждом подпроекте будут только необходимые для него данные.
- Reducer-ы содержат понятное описание изменений состояния приложения и прочитав их, можно получить достаточно полное представление, как оно вообще работает.
- State является единым источником правды для всего приложения. Поэтому исключены баги, когда приложение в разных местах отображая логически одни и те же данные, на деле показывает разные данные. Любые изменения в State автоматически транслируются на все активные View. Что особенно актуально для приложений связанных с безопасностью и финансами.
- ReduxVM при всей своей мощи достаточно простая в освоении архитектура и требует на полное освоение с помощью знакомого с ней человека около дня чистого времени.
- ReduxVM позволяет отделить бизнес логику от сайд эффектов.
- Реализация State выполнена на обычных структурах Swift, которые являются немутабельными, поэтому не надо опасаться случайных изменений в Store не прошедших путь заданный архитектурой.
- Платформонезависимость: все элементы ReSwift — Stores, Reducers и Actions — независимы от платформы. Их можно легко использовать повторно для iOS, macOS или tvOS, разделять бизнеслогику между приложениями на iPhone и iPad.

Минусы:

Минусы больше относятся к чистой Redux архитектуре. Поэтому рядом с минусом сразу указывается решение проблемы в рамках ReduxVM.

- Большая модульность ведет к большому количеству файлов. Поэтому даже несложные изменения могут потребовать редактирования сразу в нескольких местах. Что требует полного владения архитектурой. _В ReduxVM есть шаблоны, которые генерируют автоматически все нужные файлы и связи между ними для ViewController._
- Так как State может быть большим, то нужно быть аккуратным с написанием Reducer, чтобы они не занимали много времени. _В ReduxVM эта часть кода работает в фоновом потоке, поэтому влияние на UI снижается._
- Разработка модели данных является более сложной, чем в других подходах. В тоже время после того как модель разработана, становится гораздо понятнее работа со всем приложением.
- Подход мотивирует пользоваться декларативным стилем программирования. _Подавляющее большинство проблем вытекающих из этого решены в ReduxVM введением Presenter и Props, а также написанием сервисных классов для таблиц и коллекций работающих в декларативном стиле. В ReduxVM используется библиотека DeclarativeTVC для работы со списочными интерфейсами._
